---
title: "Metricas de rede"
format: 
  html:
    toc: true
    toc-depth: 5
    toc-location: left
    embed-resources: true
execute: 
  cache: true
---

```{r}
#| label: setup
#| warning: false

library(tidyverse)
`%!in%` <- negate(`%in%`)
options(scipen = 99)
```

## Carregando dados

```{r}
#| label: carrega-likes

likes <- read_rds("Dados/likes.rds")
liker.actors <- read_rds("Dados/liker-actors.rds") # só tenho os dids
liked.actors <- read_rds("Dados/liked-actors.rds") # só tenho os dids
likes.actors <- read_rds("Dados/likes-actors.rds") # só tenho o total dos dids
```

é preciso montar um dicionário de did's e handle's tomando quatro cuidados:

- numerar sequencialmente os handle == "handle.invalid" em "handle.invalid.1" em diante função de did diferente
- criar um handle "handle.missing.1" em diante para is.na(handle)
- str_remove(handle, ".bsky.social$") --> que não tiver, já fica como está
- colar os handles de que mudou pelo meio do caminho: "joao.bsky.social" e "joca.bsky.social" no mesmo did viram "joao/joca"

```{r}
view(likes)
```


## Criticando lista de likers

```{r}
liker.actors |> 
  group_by(from.handle == "handle.invalid") |> 
  summarise(quantos = n())
```

`r sum(liker.actors$from.handle == "handle.invalid")` actors não têm mais handles válidos, então esses actors serão agrupados erradamente como um único actor se agrupar por handle.

tirando sufixo e filtrando handle.invalid, depois colocando sufixo nos handles diferentes (está indo nos dids diferentes?)

```{r}

dicionario <- likes |>
  distinct(
    did = from.actor, 
    handle = from.handle) |>
  mutate(
    handle = str_remove(
      handle,
      "\\.bsky\\.social$"
    )
  ) |>
  #filtro pra ficar mais fácil de ver
 # filter(handle == "handle.invalid") |>
    add_count(handle, name = "n_handle") |>
      mutate(
        handle = case_when(
          #numera did
          n_handle > 1 ~ paste0("handle.invalid", row_number()),
          TRUE ~ handle
        )
      ) |>
    select (
      did,
      handle
    )
```


tirando sufixo e filtrando handle.invalid, depois colocando sufixo nos handles diferentes (está indo nos handles diferentes?) GPT

```{r}
library(dplyr)
library(stringr)

dic2 <- likes |>
  distinct(
    did = from.actor,
    handle = from.handle
  ) |>
  
  # 1️⃣ Remove o sufixo
  mutate(
    handle = str_remove(handle, "\\.bsky\\.social$")
  ) |>
  
  # 2️⃣ Substitui NA por handle.missing temporário
  mutate(
    handle = case_when(
      is.na(handle) ~ paste0("handle.missing.", row_number()),
      TRUE ~ handle
    )
  ) |>
  
  # 3️⃣ Consolida DIDs com mais de um handle ao longo do tempo
  group_by(did) |>
  summarise(
    handle = paste(sort(unique(handle)), collapse = "/")
  ) |>
  ungroup() |>
  
  # 4️⃣ Agora sim, tratar handles problemáticos  
  add_count(handle, name = "n_handle") |>
    filter(handle == "handle.invalid") |>
  
  
  #ATÉ AQUI TA IGUAL EM CIMA, A PARTIR ELE N MOSTRA
  
  
  mutate(
    handle = case_when(
      # se o handle aparece com vários DIDs → invalid + numeração
      n_handle > 1 ~ paste0("handle.invalid.", row_number()),
      TRUE ~ handle
    )
  ) |>
  select(-n_handle)

```


```{r}

# Dicionário base
dic3 <- likes |>
  distinct(did = from.actor, handle = from.handle)

# 1️⃣ Remover sufixo ".bsky.social"
dic3 <- dic3 |>
  mutate(handle = str_remove(handle, "\\.bsky\\.social$"))

# 2️⃣ Tratar valores NA -> handle.missing.N
dic3 <- dic3 |>
  mutate(
    handle = if_else(
      is.na(handle),
      paste0("handle.missing.", row_number()),
      handle
    )
  )

# 3️⃣ Identificar handles repetidos entre DIDs diferentes (handle inválido)
dic3 <- dic3 |>
  add_count(handle, name = "n_handle") |>
  mutate(
    handle = case_when(
      # Se o handle aparece em mais de um did → numerar invalid
      n_handle > 1 ~ paste0("handle.invalid.", row_number()),
      TRUE ~ handle
    )
  ) |>
  select(-n_handle)

# 4️⃣ Consolidar handles diferentes para o mesmo DID
#     Se um DID mudou de handle → juntar em ordem alfabética
dic_final3 <- dic3 |>
  group_by(did) |>
  summarise(
    handles = paste(sort(unique(handle)), collapse = "/")
  ) |>
  ungroup()

dic_final3

```

