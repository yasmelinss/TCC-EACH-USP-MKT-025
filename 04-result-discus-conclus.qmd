# Resultados

## Descritivas


### Medidas descritivas — Posts da query "CBLOL"

`skeets.longo`

```{r echo=FALSE, warning=FALSE, message=FALSE}
#| label: medidas-skeets

library(tidyverse)
library(dplyr)
library(lubridate)
library(knitr)

skeets.longo <- read_rds("Dados/skeets-longo.rds")

# Selecionar colunas relevantes
skeets_desc <- skeets.longo |>
  select(reply_count, repost_count, like_count, quote_count, indexed_at)

# Calcular medidas descritivas com arredondamento para PDF
descr_pdf <- skeets_desc |>
  summarise(
    n_posts          = n(),

    media_respostas    = round(mean(reply_count, na.rm = TRUE), 2),
    mediana_respostas  = round(median(reply_count, na.rm = TRUE), 2),
    desvio_respostas   = round(sd(reply_count, na.rm = TRUE), 2),
    maximo_respostas   = round(max(reply_count, na.rm = TRUE), 0),
  )
descr2_pdf <- skeets_desc |>
  summarise(

    media_reposts      = round(mean(repost_count, na.rm = TRUE), 2),
    mediana_reposts    = round(median(repost_count, na.rm = TRUE), 2),
    desvio_reposts     = round(sd(repost_count, na.rm = TRUE), 2),
    maximo_reposts     = round(max(repost_count, na.rm = TRUE), 0),
)
descr3_pdf <- skeets_desc |>
  summarise(
    media_likes        = round(mean(like_count, na.rm = TRUE), 2),
    mediana_likes      = round(median(like_count, na.rm = TRUE), 2),
    desvio_likes       = round(sd(like_count, na.rm = TRUE), 2),
    maximo_likes       = round(max(like_count, na.rm = TRUE), 0),
)
descr4_pdf <- skeets_desc |>
  summarise(
    media_quotes       = round(mean(quote_count, na.rm = TRUE), 2),
    mediana_quotes     = round(median(quote_count, na.rm = TRUE), 2),
    desvio_quotes      = round(sd(quote_count, na.rm = TRUE), 2),
    maximo_quotes      = round(max(quote_count, na.rm = TRUE), 0)
  )

descr_pdf |>
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Medidas descritivas dos posts contendo a palavra-chave 'CBLOL' - respostas"
  )
descr2_pdf |>
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Medidas descritivas dos posts contendo a palavra-chave 'CBLOL' - reposts"
  )
descr3_pdf |>
  kable(    
    format = "latex",
    booktabs = TRUE,
    caption = "Medidas descritivas dos posts contendo a palavra-chave 'CBLOL' - likes"
    )
descr4_pdf |>
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Medidas descritivas dos posts contendo a palavra-chave 'CBLOL' - quotes"
  )
```

### Medidas descritivas — Likes extraidos desses posts

`matriz.like`

(A) Gerais


```{r echo=FALSE, warning=FALSE, message=FALSE}
#| label: medidas-likes

matriz.likes <- read_rds("Dados/matriz-likes.rds")

gerais_matriz <- matriz.likes |>
  summarise(
    total_linhas     = n(),
    dias_unicos      = n_distinct(as.Date(data.skeet)), #ver melhor
    atores_influencers = n_distinct(actor.influencer.num),
    atores_influenced  = n_distinct(actor.influenced.num),
    atores_totais    = n_distinct(c(actor.influencer.num, actor.influenced.num)),
    pares_interacao  = n_distinct(paste(actor.influencer.num, actor.influenced.num, sep = "_"))
  )

gerais_matriz |>
  t() |>
  as.data.frame() |>
  kable(
    format = "latex",
    booktabs = TRUE,
    col.names = c("Valor"),
    caption = "Descritivas gerais da matriz de likes"
  ) |>
  kableExtra::kable_styling(latex_options = "hold_position")


```

(B) Graus

```{r echo=FALSE, warning=FALSE, message=FALSE}
#| label: medidas-likes-grau

graus_totais <- matriz.likes |>
  summarise(
    media_likes_dados     = round(mean(table(actor.influenced.num)), 2),
    mediana_likes_dados   = round(median(table(actor.influenced.num)), 2),
    desvio_likes_dados    = round(sd(table(actor.influenced.num)), 2),
    max_likes_dados       = max(table(actor.influenced.num)),
    min_likes_dados       = min(table(actor.influenced.num)),

    media_likes_recebidos   = round(mean(table(actor.influencer.num)), 2),
    mediana_likes_recebidos = round(median(table(actor.influencer.num)), 2),
    desvio_likes_recebidos  = round(sd(table(actor.influencer.num)), 2),
    max_likes_recebidos     = max(table(actor.influencer.num)),
    min_likes_recebidos     = min(table(actor.influencer.num))
  )

graus_totais |>
  t() |>
  as.data.frame() |>
  kable(
    format = "latex",
    booktabs = TRUE,
    col.names = c("Valor"),
    caption = "Distribuição geral dos likes dados (out-degree) e recebidos (in-degree)"
  ) 

```


(C) Top 10 atores mais ativos e mais curtidos


```{r echo=FALSE, warning=FALSE, message=FALSE}
#| label: medidas-likes-top10

dicionario.handles <- read_rds("Dados/dicionario.rds") |>
  mutate(num = as.character(num))

# top 10 que mais curtiram (out-degree)
top_out <- matriz.likes |>
  mutate(actor.influencer.num = as.character(actor.influencer.num)) |>
  count(actor.influencer.num, name = "likes_recebidos") |>
  left_join(
    dicionario.handles |> select(num, handle),
    by = c("actor.influencer.num" = "num")
  ) |>
  select(handle, likes_recebidos) |>
  arrange(desc(likes_recebidos)) |>
  slice(1:10)

# top 10 mais curtidos (in-degree)
top_in <- matriz.likes |>
  mutate(actor.influenced.num = as.character(actor.influenced.num)) |>
  count(actor.influenced.num, name = "likes_dados") |>
  left_join(
    dicionario.handles |> select(num, handle),
    by = c("actor.influenced.num" = "num")
  ) |>
  select(handle, likes_dados) |>
  arrange(desc(likes_dados)) |>
  slice(1:10)

top_out |>
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Top 10 atores que mais foram curtidos (out-degree)"
  )

top_in |>
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Top 10 atores que mais curtiram (in-degree)"
  )

```


(D) Grau médio, densidade simples e razão entre nós e arestas

#### Medidas simples de estrutura da rede

```{r echo=FALSE, warning=FALSE, message=FALSE}
#| label: medidas-geral

# número de nós
n_atores <- matriz.likes |>
  summarise(n = n_distinct(c(actor.influencer.num, actor.influenced.num))) |>
  pull()

# número de arestas (interações únicas)
n_arestas <- matriz.likes |>
  summarise(n = n_distinct(paste(actor.influencer.num, actor.influenced.num))) |>
  pull()

# densidade simples (não-direcionada aproximada)
densidade_simples <- round(n_arestas / (n_atores * (n_atores - 1)), 6)

medidas_rede <- tibble::tibble(
  atores_totais   = n_atores,
  arestas_unicas  = n_arestas,
  densidade       = densidade_simples,
  grau_medio      = round(n_arestas / n_atores, 3)
)

medidas_rede |>
  kable(
    format = "latex", 
    booktabs = TRUE,
    caption = "Medidas gerais de estrutura da rede de likes"
  )
```


```{r echo=FALSE, warning=FALSE, message=FALSE}
library(dplyr)
library(knitr)
library(kableExtra)

# carregar a métrica agregada (ou usar o objeto já criado)
metricas_agregadas_dia37 <- readRDS("Dados/metricas_agregadas_dia37.rds")

# selecionar os 20 primeiros
top20_dia37 <- metricas_agregadas_dia37 |>
  arrange(desc(in_degree)) |>
  slice(1:20) |>
  select(actor.num, handle, in_degree, out_degree, saldo, spread) 

# tabela horizontal compatível com PDF/LaTeX
top20_dia37 |>
  kable(
    format = "latex",
    booktabs = TRUE,
    caption = "Top 20 atores com maior in-degree (likes recebidos) no dia 37"
  ) 
```











# Discussão

# Conclusão

## Principais achados

## Limitações e Trabalhos Futuros

A metodologia de coleta de dados deste estudo limitou-se à extração de *skeets* que continham o termo exato "CBLOL" em sua sigla. Para pesquisas futuras, sugere-se que futuras investigações expandam a abrangência da análise realizada neste trabalho. Uma forma de enriquecer o estudo seria desenvolvendo métodos para identificar e incorporar interações contextuais e discursivas que gravitam em torno do tema, como *skeets* que utilizam variações do termo CBLOL e termos associados, ou que são partes de respostas, citações ou *threads* onde o tema está implícito ou sendo diretamente comentado, permitindo uma análise de maior amplitude sobre o tópico na plataforma digital.

O presente estudo utilizou como métrica principal as curtidas ao longo de um período de 15 semanas. No entanto, as *threads*, que representam "fios" de diálogo entre usuários e incluem todas as respostas e citações com um mesmo *skeet* inicial, foram pouco utilizadas na análise pela dificuldade de automatizar a filtragem dos conteúdos presentes nestas para garantir que tivessem associação comprovável com o objeto de estudo. Se inclusas na mineração de dados de forma confiável, estas poderiam ampliar significativamente o volume de dados para análise.

Alternativamente, uma abordagem distinta para o mapeamento da comunidade brasileira de *e-sports* de LoL no Bluesky seria a construção de grafos centrados em atores relevantes. O canal de trasmissão Ilha das Lendas, onde um grupo de ex-jogadores fazem *co-stream* de todas as ligas de LoL, possui um perfil no Bluesky desde 29 de agosto de 2024 e continuou ativo durante toda a suspensão do X no Brasil, atingindo mais de 34,5 mil seguidores. Utilizando os seguidores como métrica principal, torna-se viável identificar outros influenciadores conectados a esse perfil e analisar sequencialmente suas listas de seguindo e seguidores, de forma a construir uma representação gráfica da comunidade como um todo, em que a aplicação de medidas de centralidade nos vértices permitiria determinar quais atores teoricamente detêm maior poder de influência e disseminação de informação na rede.

Outra possibilidade para a análise de redes sociais no Bluesky seria a aplicação da análise de sentimentos (também conhecida como mineração de opiniões),  que consiste no processo de analisar computacionalmente e identificar opiniões e julgamentos de um texto linguístico [@Chakraborty2023]. Enquanto este estudo focou em métricas quantitativas de engajamento, a implementação computacional da identificação de julgamentos em textos linguísticos ofereceria uma camada qualitativa aos dados. A aplicação desta técnica, como evidenciada em estudos do X antes das restrições de sua API [@Messaoudi2022; @Bian2016; @Bhattacharjee2017], permitiria não apenas medir a evolução do volume de interações, mas também classificar a polaridade das opiniões da comunidade.
