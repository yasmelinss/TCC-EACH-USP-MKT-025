---
title: "Tratamento dos dados de *likes* em *skeets*"
format: 
  html:
    toc: true
    toc-depth: 5
    toc-location: left
    embed-resources: true
execute: 
  cache: true
---

```{r}
#| label: setup
#| warning: false

library(tidyverse)
`%!in%` <- negate(`%in%`)
```
## Dados de likes

Montando lista de likes

```{r}
#| label: carrega-likes

likes <-
  list.files(
    path = "Dados/likes", 
    pattern = "*.rds",
    full.names = TRUE
  ) |> 
  map(
    \(nome) {
      read_rds(nome) |> 
        mutate(
          uri.skeet = 
            nome |> 
            str_remove("\\..*$") |> 
            str_replace("^", "at://did:plc:") |> 
            str_replace("-", "/app.bsky.feed.post/"),
          data.skeet = created_at,
          to.actor =
            nome |> 
            str_remove("\\..*$") |> 
            str_replace("Dados/likes/", "did:plc:") |> 
            str_remove("-.*$"),
          from.actor = 
            actor_data |> 
            map_chr(\(x) x$did),
          from.handle =
            actor_data |> 
            map_chr(\(x) x$handle),
          .keep = "none"
        )
    }
  ) |> 
  list_rbind() 

likes |> write_rds("Dados/likes.rds")
```

Criando listas de actors relacionados com likes

```{r}
#| label: criando-likes-actors

# quem curtiu
liker.actors <- 
  likes |> 
  select(from.actor, from.handle) |> 
  unique()
liker.actors |> write_rds("Dados/liker-actors.rds")

# quem foi curtido
liked.actors <- 
  likes$to.actor |> 
  unique()
liked.actors |> write_rds("Dados/liked-actors.rds")

# quem curtiu ou foi curtido
likes.actors <- 
  c(liker.actors$from.actor, liked.actors) |> 
  unique()
likes.actors |> write_rds("Dados/likes-actors.rds")
```

Montando a matriz de likes dados

```{r}
#| label: monta-matriz-likes

all.actors.likes <- 
  tibble(
    did = 
      c(likes$from.actor, likes$to.actor) |> 
      unique() |> 
      sort()
  ) |> 
  left_join(
    likes |> distinct(did = from.actor, handle = from.handle),
    by = "did"
  ) |>
  mutate(num = row_number())

all.actors.likes |> write_rds("Dados/all-actors-likes.rds")
```


```{r}
matriz.likes <- 
  likes |> 
  left_join(
    all.actors.likes,
    by = c("from.actor" = "did")
  ) |> 
  rename(actor.influenced.num = num) |> 
  left_join(
    all.actors.likes,
    by = c("to.actor" = "did")
  ) |> 
  rename(actor.influencer.num = num) |> 
  select(
    data.skeet, 
    actor.influencer.num,
    actor.influenced.num
  )
matriz.likes |> write_rds("Dados/matriz-likes.rds")
```


## Dados de skeets

Carregando a versão curta

```{r}
#| label: carrega-skeets

skeets <- read_rds("Dados/skeets-curto.rds")
```

Montando lista de envolvidos em skeets

```{r}
#| label: criando-skeets-actors

all.actors.skeets <- 
  tibble(
    did =
      c(
        skeets$did.autor,
        skeets$uri.post |> 
          str_remove("at://") |> 
          str_remove("/app.bsky.feed.post/.*$"),
        skeets$uri.reply |> 
          str_remove("at://") |> 
          str_remove("/app.bsky.feed.post/.*$")
      ) |> 
      unique() |> 
      sort()
  ) |> 
  mutate(num = row_number())
all.actors.likes |> write_rds("Dados/all-actors-likes.rds")
  
matriz.skeets <- 
  skeets |> 
  left_join(
    all.actors.skeets,
    by = c("did.autor" = "did")
  ) |> 
  rename(actor.influenced.num = num) |> 
  mutate(
    did.replied.to = 
      uri.reply |> 
      str_remove("at://") |> 
      str_remove("/app.bsky.feed.post/.*$")
  ) |> 
  left_join(
    all.actors.skeets,
    by = c("did.replied.to" = "did")
  ) |> 
  rename(actor.influencer.num = num) |> 
  select(
    data.post, 
    actor.influencer.num,
    actor.influenced.num
  )
matriz.skeets |> write_rds("Dados/matriz-skeets.rds")
```

Separando os skeets com "cblol" em iniciais e replies/quotes

```{r}
#| label: separando-skeets-iniciais-replies-quotes

skeets.separados <- 
  skeets |> 
  group_by(is.na(uri.reply)) |> # FALSE = reply/quote e TRUE = original
  group_split(.keep = FALSE) |> 
  # set_names(c("reply.quote", "original"))
```



## Dicionário de actors

Precisa:

- juntar todos os did's já encontrados com os handles quando presentes
- numerar sequencialmente os "handle.invalid" de did's diferentes
- criar um "handle.missing" quando is.na(handle)
- remover o ".bsky.social" de quem tiver
- colar os handles dos did's que mudaram de handle pelo meio do caminho

Buscando os skeets longos

```{r}
#| label: carrega-skeets-longo

skeets.longo <- read_rds("Dados/skeets-longo.rds")
```

Montando a lista de did's e handles

```{r}
#| label: monta-did-handle

did.handle.unicos <- 
  bind_rows(
    skeets.longo |> select(did = uri, handle = author_handle),
    skeets.longo |> select(did = uri, handle = author_handle),
    skeets.longo |> select(did = in_reply_to),
    skeets.longo |> select(did = quotes),
  ) |> 
  filter(!is.na(did)) |> 
  mutate(
    did =
      did |> 
      str_remove("^at://") |> 
      str_remove("/app.*$")
  ) |> 
  bind_rows(
    likes |> select(did = from.actor, handle = from.handle),
    likes |> select(did = to.actor),
  ) |> 
  arrange(did, handle) |> 
  distinct()
```

Tem muita gente com múltiplos handles?

```{r}
did.handle.unicos |> 
  group_by(did) |> 
  summarise(
    quantos.handles = n(),
    any.handle.na = any(is.na(handle)),
    any.handle.invalid = any(handle == "handle.invalid")
  ) |> 
  count(
    quantos.handles,
    any.handle.na,
    any.handle.invalid,
  )
```

```{r}
did.handle.unicos |> 
  group_by(did) |> 
  filter((n() == 1) | (n() > 1 & !is.na(handle))) |> 
  summarise(
    quantos.handles = n(),
    any.handle.na = any(is.na(handle)),
    any.handle.invalid = any(handle == "handle.invalid")
  ) |> 
  count(
    quantos.handles,
    any.handle.na,
    any.handle.invalid,
  )
```

Não. Só há 3 situações:

- ou apenas handle NA, 
- ou apenas handle inválido 
- ou apenas um único handle válido

Montando o dicionários de handles

- numerar sequencialmente os "handle.invalid" de did's diferentes
- criar um "handle.missing" quando is.na(handle)
- remover o ".bsky.social" de quem tiver
- colar os handles dos did's que mudaram de handle pelo meio do caminho

```{r}
#| label: monta-dicionario-handles

dicionario.handles <- 
  did.handle.unicos |> 
  group_by(did) |> 
  filter(n() == 1 | n() > 1 & !is.na(handle)) |> 
  ungroup() |> 
  mutate(
    handle = 
      if_else(
        is.na(handle), 
        "handle.missing", 
        handle
      )
  ) |> 
  group_by(handle) |> # só missing e invalid é que sejam juntados 
  mutate(
    handle =
      if_else(
        n() == 1 + 0 * nchar(handle),
        handle |> 
          str_remove(fixed(".bsky.social")),
        handle |> 
          str_c(".", seq(n()))
      )
  )
dicionario.handles |> write_rds("Dados/dicionario-handles.rds")
```

## Se precisar, carregando do disco o que já foi processado

Só executa se avaliado manualmente

```{r}
#| label: recarrega-dados
#| eval: false

# likes
likes <- read_rds("Dados/likes.rds")
liker.actors <- read_rds("Dados/liker-actors.rds")
liked.actors <- read_rds("Dados/liked-actors.rds")
likes.actors <- read_rds("Dados/likes-actors.rds")
all.actors.likes <- read_rds("Dados/all-actors-likes.rds")
matriz.likes <- read_rds("Dados/matriz-likes.rds")
# skeets
matriz.skeets <- read_rds("Dados/matriz-skeets.rds")
all.actors.likes <- read_rds("Dados/all-actors-likes.rds")
skeets.separados$original <- read_rds("Dados/skeets-iniciais.rds")
skeets.separados$reply.quote <- read_rds("Dados/skeets-reply-quote.rds")
```

